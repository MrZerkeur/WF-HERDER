"use client"
import { Canvas, useLoader , useFrame} from '@react-three/fiber';
import { useRef, useEffect } from 'react';
import { Mesh } from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { MeshStandardMaterial, TextureLoader } from 'three';
import { Quaternion, Vector3 } from 'three';
import { RepeatWrapping } from 'three';

export const ModelViewer: React.FC = () => {
    const containerRef = useRef<HTMLDivElement>(null);
    const modelVisible = useRef(false);

    
    useEffect(() => {
        const observer = new IntersectionObserver(
            (entries) => {
                entries.forEach((entry) => {
                    modelVisible.current = entry.isIntersecting;
                });
            },
            { threshold: 0.5 } 
        );

        if (containerRef.current) {
            observer.observe(containerRef.current);
        }

        return () => {
            if (containerRef.current) {
                observer.unobserve(containerRef.current);
            }
        };
    }, []);

    return (
        <div ref={containerRef} style={{ height: '100%', width: '100%' }}>
            
            <Canvas style={{ backgroundColor: '#f8f8f8' }}>
                <EthereumModel isVisible={modelVisible} containerRef={containerRef} />
            </Canvas>
        </div>
    );
};

interface EthereumModelProps {
    isVisible: React.MutableRefObject<boolean>;
    containerRef: React.RefObject<HTMLDivElement>;
}

export const EthereumModel: React.FC<EthereumModelProps> = ({ isVisible ,containerRef}) => {
    const myModel = useLoader(GLTFLoader, '/sidiali.glb');
    const screenTexture = useLoader(TextureLoader, '/phonem/nari.png'); 
    const modelRef = useRef<Mesh>(null);

    // useEffect(() => {
    //     if (myModel && myModel.scene) {
            
    //         screenTexture.wrapS = RepeatWrapping;
    //         screenTexture.wrapT = RepeatWrapping;
    //         screenTexture.repeat.set(-1, -1); 
    //         screenTexture.needsUpdate = true;
    //         myModel.scene.traverse((object) => {
    //             if (object instanceof Mesh) {
                    
    //                 if (object.name === 'YbXWdqEcjbfTKuN_0') {
                    
    //                     object.material = new MeshStandardMaterial({
    //                         map: screenTexture, 
    //                         metalness: 0.0,     
    //                         roughness: 1.0, 
    //                     });
    //                 }
    //             }
    //         });
    //     }
    // }, [myModel, screenTexture]); 

    
    useEffect(() => {
        const rotationAxis = new Vector3(0, 1, 0);
        const quaternian = new Quaternion().setFromAxisAngle(rotationAxis, 1);
        modelRef.current?.quaternion.multiplyQuaternions(modelRef.current.quaternion, quaternian);
        let x = 1.5;
        modelRef.current?.position.setY(x);
        const handleScroll = () => {
            if (modelRef.current && isVisible.current) {
                x= x - 0.08;                
                const rotationAmount = -0.04;
                const quaternion = new Quaternion().setFromAxisAngle(rotationAxis, rotationAmount);
                if (modelRef.current.quaternion.y > -0.5) {
                    modelRef.current.quaternion.multiplyQuaternions(modelRef.current.quaternion, quaternion);
                    modelRef.current.position.setY(x);
                }
            }
        };

        window.addEventListener('scroll', handleScroll);

        return () => {
            window.removeEventListener('scroll', handleScroll);
        };
    }, [modelRef, isVisible]);



    return (
        <>
            <pointLight position={[-10, -10, -10]} color="#fff" intensity={5000} />
            <pointLight position={[10, 10, 10]} color="#fff" intensity={900} />
            <primitive object={myModel.scene} ref={modelRef} scale={[8, 8, 8]} rotation={[0, 0, 150]} />
        </>
    );
};



SASDASD

  // useFrame(() => {
  //   if (helperRef.current) {
  //     const angle = 0.01;
  //     helperRef.current.rotation.y += angle;
  //   }
  // });

SASADSD